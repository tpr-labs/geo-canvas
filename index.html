<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>GeoCanvas | Version 0.1</title>

    <!-- Browser Tab Icon -->
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>üåç</text></svg>">

    <!-- Leaflet Core -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

    <!-- Leaflet Draw -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.css" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.js"></script>

    <!-- Geometry Utils -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet-geometryutil/0.10.2/leaflet.geometryutil.min.js"></script>

    <!-- Search & Utils -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet-geosearch@3.8.0/dist/geosearch.css" />
    <script src="https://unpkg.com/leaflet-geosearch@3.8.0/dist/bundle.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" />
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">

    <style>
        :root {
            --primary: #000000;
            --accent: #2563eb;
            --surface: #ffffff;
            --bg: #f8fafc;
            --text-main: #0f172a;
            --border: #e2e8f0;
            --danger: #ef4444;
            --success: #22c55e;
            --sidebar-width: 360px;
        }

        body, html { margin: 0; padding: 0; height: 100%; font-family: 'Inter', sans-serif; overflow: hidden; background: var(--bg); }
        .app-container { display: flex; height: 100vh; width: 100vw; transition: all 0.3s; }
        * { box-sizing: border-box; }

        /* --- Sidebar --- */
        .sidebar {
            width: var(--sidebar-width);
            background: var(--surface);
            border-right: 1px solid var(--border);
            display: flex; flex-direction: column; z-index: 1001; box-shadow: 4px 0 24px rgba(0,0,0,0.05);
            transition: width 0.3s ease, padding 0.3s ease;
            overflow: hidden; white-space: nowrap; flex-shrink: 0;
        }
        .sidebar.collapsed { width: 0; padding: 0; border-right: none; }

        .sidebar-header {
            padding: 20px; background: var(--surface); border-bottom: 1px solid var(--border);
            display: flex; align-items: center; justify-content: space-between;
        }

        .app-brand { display: flex; align-items: center; gap: 12px; margin-bottom: 15px; }
        .brand-icon {
            width: 36px; height: 36px; background: linear-gradient(135deg, #2563eb, #1e40af);
            color: white; border-radius: 10px; display: flex; align-items: center; justify-content: center;
            font-size: 18px; box-shadow: 0 4px 6px -1px rgba(37, 99, 235, 0.2);
        }
        .brand-text h1 { font-size: 20px; font-weight: 700; margin: 0; color: var(--text-main); letter-spacing: -0.5px; }
        .brand-text p { font-size: 11px; margin: 0; color: #64748b; font-weight: 500; text-transform: uppercase; letter-spacing: 0.5px; }

        .search-wrapper { position: relative; display: flex; gap: 8px; }
        .search-input { flex: 1; padding: 10px; border: 1px solid var(--border); border-radius: 6px; outline: none; font-size: 13px; transition: border 0.2s; }
        .search-input:focus { border-color: var(--accent); }

        .search-results {
            position: absolute; top: 100%; left: 0; right: 0; background: white;
            border: 1px solid var(--border); border-radius: 6px; margin-top: 4px;
            max-height: 200px; overflow-y: auto; display: none; z-index: 2000;
            box-shadow: 0 10px 15px -3px rgba(0,0,0,0.1);
        }
        .search-item { padding: 10px; font-size: 12px; cursor: pointer; border-bottom: 1px solid #f1f5f9; }
        .search-item:hover { background: #f8fafc; color: var(--accent); }

        .sidebar-content { flex: 1; overflow-y: auto; padding: 20px; display: flex; flex-direction: column; gap: 24px; }
        .tool-section h4 { font-size: 11px; text-transform: uppercase; color: #64748b; margin: 0 0 10px 0; font-weight: 700; border-bottom: 1px solid var(--border); padding-bottom: 5px; }

        /* --- Controls --- */
        .control-row { display: flex; gap: 10px; align-items: center; margin-bottom: 10px; }
        .btn {
            background: white; border: 1px solid var(--border); color: var(--text-main); padding: 10px;
            border-radius: 6px; cursor: pointer; font-size: 13px; font-weight: 500; display: flex;
            align-items: center; justify-content: center; gap: 8px; flex: 1; transition: all 0.2s;
        }
        .btn:hover { background: #f1f5f9; }
        .btn.active { background: #f3f4f6; border-color: var(--text-main); color: var(--text-main); font-weight: 700; }
        .btn.primary { background: var(--text-main); color: white; border-color: var(--text-main); }
        .btn.primary:hover { background: #333; }

        .btn-edit-mode { background: #fdf4ff; color: #a21caf; border-color: #f0abfc; }
        .btn-edit-mode:hover { background: #fce7f3; }
        .btn-edit-mode.active { background: #22c55e; color: white; border-color: #16a34a; }

        .btn-icon-only { width: 32px; height: 32px; padding: 0; flex: 0 0 32px; border: none; background: transparent; color: #64748b; }
        .btn-icon-only:hover { background: #f1f5f9; color: var(--text-main); }

        .tool-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }

        #sidebar-open-btn {
            position: absolute; top: 20px; left: 20px; z-index: 1002;
            background: white; border: 2px solid rgba(0,0,0,0.2); width: 40px; height: 40px; border-radius: 8px;
            display: none; align-items: center; justify-content: center; cursor: pointer;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15); color: var(--text-main); font-size: 16px; transition: transform 0.2s;
        }
        #sidebar-open-btn:hover { transform: scale(1.05); }

        input[type="number"] { width: 80px; padding: 8px; border: 1px solid var(--border); border-radius: 6px; }
        input[type="color"] { border: none; width: 40px; height: 40px; cursor: pointer; background: none; }

        /* --- Layer Grid --- */
        .layer-grid { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 8px; }
        .layer-btn { border: 1px solid var(--border); border-radius: 6px; padding: 8px; text-align: center; cursor: pointer; background: white; }
        .layer-btn img { width: 100%; height: 40px; object-fit: cover; border-radius: 4px; filter: grayscale(100%); transition: 0.2s; }
        .layer-btn:hover img { filter: grayscale(0%); }
        .layer-btn.active { border-color: var(--text-main); background: #f3f4f6; }
        .layer-btn.active img { filter: none; }
        .layer-btn span { display: block; font-size: 11px; font-weight: 600; margin-top: 5px; }

        /* --- Map & Overlays --- */
        .map-wrapper { flex: 1; position: relative; }
        #map { height: 100%; width: 100%; z-index: 1; }

        /* Capture Mode */
        body.capture-mode .sidebar { display: none !important; }
        body.capture-mode .map-wrapper { width: 100vw !important; height: 100vh !important; position: fixed; top:0; left:0; z-index: 9999; }
        body.capture-mode #map { width: 100% !important; height: 100% !important; }
        body.capture-mode .leaflet-control-container { display: none !important; }

        .custom-label {
            background: rgba(255, 255, 255, 0.95); padding: 4px 8px; border-radius: 4px;
            border: 1px solid #333; font-weight: 600; font-size: 12px; white-space: nowrap;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1); cursor: pointer;
        }

        /* Measurement Labels */
        .measure-label {
            background: transparent; border: none; box-shadow: none;
            color: white; font-weight: 800; font-size: 11px;
            text-shadow: -1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000, 1px 1px 0 #000;
            white-space: nowrap;
        }
        .measure-label-area {
            color: #facc15; font-size: 13px; text-shadow: -1px -1px 2px black, 1px 1px 2px black;
        }
        /* Radius label specifically for circles */
        .radius-label-marker {
            background: transparent; border: none; box-shadow: none;
            color: #0f172a; font-weight: 800; font-size: 12px;
            text-shadow: 1px 1px 0 #fff, -1px -1px 0 #fff, 1px -1px 0 #fff, -1px 1px 0 #fff;
            white-space: nowrap;
        }

        /* Helpers */
        #context-menu {
            position: absolute; display: none; background: white; border: 1px solid var(--border);
            border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); width: 220px; z-index: 3000;
            padding: 12px; font-family: 'Inter', sans-serif;
        }
        #context-menu h5 { margin: 0 0 10px 0; font-size: 13px; border-bottom: 1px solid #eee; padding-bottom: 5px; }
        .ctx-group { margin-bottom: 10px; }
        .ctx-input { width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px; font-size: 12px; }
        .ctx-actions { display: flex; gap: 8px; margin-top: 10px; }

        #draw-helper {
            position: absolute; top: 20px; left: 50%; transform: translateX(-50%);
            background: rgba(0,0,0,0.8); color: white; padding: 8px 16px; border-radius: 20px;
            font-size: 12px; z-index: 2000; display: none; pointer-events: none;
        }

        #share-modal {
            display: none; position: fixed; inset: 0; background: rgba(0,0,0,0.5); z-index: 4000;
            align-items: center; justify-content: center;
        }
        .modal-content {
            background: white; padding: 20px; border-radius: 8px; width: 400px; max-width: 90%;
            box-shadow: 0 10px 25px rgba(0,0,0,0.2);
        }
        .url-box {
            width: 100%; background: #f1f5f9; border: 1px solid #e2e8f0; padding: 10px;
            font-size: 12px; color: #475569; word-break: break-all; border-radius: 4px;
            margin: 10px 0; max-height: 80px; overflow-y: auto;
        }

        /* Snap Marker */
        .snap-marker {
            background: transparent; border: 2px solid #facc15; border-radius: 50%;
            box-shadow: 0 0 0 2px rgba(0,0,0,0.3); pointer-events: none;
        }

        /* Loader */
        #toast-container { position: fixed; bottom: 30px; right: 30px; z-index: 2000; }
        .toast { background: #1e293b; color: white; padding: 12px 20px; border-radius: 8px; margin-top: 10px; font-size: 13px; animation: slideUp 0.3s ease; display: flex; align-items: center; gap: 10px; }
        @keyframes slideUp { from { transform: translateY(20px); opacity: 0; } to { transform: translateY(0); opacity: 1; } }
        .loader { position: fixed; inset: 0; background: rgba(255,255,255,0.8); z-index: 3000; display: none; align-items: center; justify-content: center; flex-direction: column; }
        .spinner { width: 40px; height: 40px; border: 4px solid #e2e8f0; border-top-color: var(--text-main); border-radius: 50%; animation: spin 1s linear infinite; margin-bottom: 10px; }
        @keyframes spin { to { transform: rotate(360deg); } }

        @media (max-width: 768px) { .app-container { flex-direction: column-reverse; } .sidebar { width: 100%; height: 50%; } }
    </style>
</head>
<body>

    <div class="app-container">
        <aside class="sidebar" id="sidebarPanel">
            <div class="sidebar-header">
                <div class="app-brand">
                    <div class="brand-icon"><i class="fa-solid fa-map-location-dot"></i></div>
                    <div class="brand-text"><h1>GeoCanvas</h1><p>Version 0.1</p></div>
                </div>
                <button class="btn btn-icon-only" onclick="toggleSidebar()" title="Minimize Sidebar"><i class="fa-solid fa-chevron-left"></i></button>
            </div>

            <div class="sidebar-content">
                <div class="search-wrapper" style="margin-bottom: 20px;">
                    <input type="text" id="searchInput" class="search-input" placeholder="Search Bengaluru..." oninput="handleSearchInput(this.value)">
                    <div id="searchResults" class="search-results"></div>
                </div>

                <div class="tool-section">
                    <h4>Map Layers</h4>
                    <div class="layer-grid">
                        <div class="layer-btn active" onclick="changeLayer('street', this)">
                            <img src="https://a.tile.openstreetmap.org/12/2929/1898.png"><span>Street</span>
                        </div>
                        <div class="layer-btn" onclick="changeLayer('google', this)">
                            <img src="https://mt1.google.com/vt/lyrs=y&x=2929&y=1898&z=12"><span>Google</span>
                        </div>
                        <div class="layer-btn" onclick="changeLayer('dark', this)">
                            <img src="https://a.basemaps.cartocdn.com/dark_all/12/2929/1898.png"><span>Dark</span>
                        </div>
                    </div>
                </div>

                <div class="tool-section">
                    <h4>Edit Items</h4>
                    <button id="btnEditMode" class="btn btn-edit-mode" onclick="toggleEditMode()">
                        <i class="fa-solid fa-arrows-up-down-left-right"></i> <span>Enable Drag & Edit</span>
                    </button>
                    <div style="font-size:11px; color:#64748b; margin-top:5px;">
                        Enable to drag circles, move text, or modify shapes.
                    </div>
                </div>

                <div class="tool-section">
                    <h4>Style</h4>
                    <div class="control-row">
                        <input type="color" id="colorPicker" value="#000000">
                        <div style="font-size:11px; color:#64748b;"><strong>Color</strong><br>Right-click items to change</div>
                    </div>
                </div>

                <div class="tool-section">
                    <h4>Drawing Tools</h4>
                    <div class="tool-grid">
                        <button class="btn" id="btnFixedCircle" onclick="activateTool('fixedCircle')">
                            <i class="fa-regular fa-circle-dot"></i> Circle (5km)
                        </button>
                        <button class="btn" id="btnDrawLine" onclick="activateTool('polyline')">
                            <i class="fa-solid fa-route"></i> Line
                        </button>
                        <button class="btn" id="btnDrawPoly" onclick="activateTool('polygon')">
                            <i class="fa-solid fa-draw-polygon"></i> Area
                        </button>
                        <button class="btn" id="btnTextTool" onclick="activateTool('text')">
                            <i class="fa-solid fa-font"></i> Text
                        </button>
                    </div>
                </div>

                <div class="tool-section" style="margin-top:auto">
                    <h4>History</h4>
                    <div class="control-row">
                        <button class="btn" onclick="undo()" title="Undo (Ctrl+Z)"><i class="fa-solid fa-rotate-left"></i> Undo</button>
                        <button class="btn" onclick="redo()" title="Redo (Ctrl+Y)"><i class="fa-solid fa-rotate-right"></i> Redo</button>
                    </div>

                    <h4>Share & Export</h4>
                    <button class="btn primary" onclick="generateShareLink()" style="width:100%; margin-bottom:10px; background:#7c3aed; border-color:#7c3aed;">
                        <i class="fa-solid fa-link"></i> Share / Save Link
                    </button>
                    <div class="control-row">
                        <button class="btn" onclick="downloadJSON()">Save JSON</button>
                        <button class="btn" onclick="document.getElementById('fileInput').click()">Load JSON</button>
                        <input type="file" id="fileInput" accept=".json" style="display:none" onchange="loadJSON(this)">
                    </div>
                    <button class="btn" onclick="clearMap()" style="width:100%; margin-top:10px; color: var(--danger); border-color: #fee2e2;">Clear All</button>
                </div>
            </div>
        </aside>

        <div class="map-wrapper">
            <button id="sidebar-open-btn" onclick="toggleSidebar()" title="Show Sidebar"><i class="fa-solid fa-bars"></i></button>
            <div id="map"></div>
            <div id="draw-helper">Snapping Active. Click last point again to finish.</div>

            <div id="context-menu">
                <h5 id="ctx-title">Edit Element</h5>
                <div class="ctx-group" id="ctx-text-group" style="display:none;">
                    <label>Label Text</label>
                    <input type="text" id="ctx-text-input" class="ctx-input">
                </div>
                <div class="ctx-group" id="ctx-radius-group" style="display:none;">
                    <label>Radius (km)</label>
                    <input type="number" id="ctx-radius-input" class="ctx-input" step="0.1">
                </div>
                <div class="ctx-group">
                    <label>Color</label>
                    <input type="color" id="ctx-color-input" style="width:100%; height:30px; cursor:pointer;">
                </div>
                <div class="ctx-actions">
                    <button class="btn primary" onclick="saveContextEdit()">Save</button>
                    <button class="btn" style="color:var(--danger); border-color:#fee2e2; background:#fef2f2;" onclick="deleteContextLayer()">Delete</button>
                </div>
            </div>

            <div id="share-modal">
                <div class="modal-content">
                    <h3 style="margin-top:0">Share Map</h3>
                    <p style="font-size:13px; color:#666;">Copy this link to save or share your current map state.</p>
                    <div class="url-box" id="share-url-box"></div>
                    <div class="control-row">
                        <button class="btn primary" onclick="copyShareLink()">Copy Link</button>
                        <button class="btn" onclick="document.getElementById('share-modal').style.display='none'">Close</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="toast-container"></div>
    <div class="loader" id="loader"><div class="spinner"></div><p>Processing...</p></div>

    <script>
        // --- Globals ---
        let map, drawnItems, helperLayer, activeTool, nativeDrawHandler, searchTimeout;
        let ctxTargetLayer = null;
        let editHandler = null;
        let isEditMode = false;
        let snapMarker = null, snapTarget = null;
        let resizeTimer;
        const layers = {};

        let historyStack = [];
        let redoStack = [];
        let isUndoingRedoing = false;

        function initMap() {
            map = L.map('map', { zoomControl: false }).setView([12.9716, 77.5946], 12);
            L.control.zoom({ position: 'topright' }).addTo(map);
            L.control.scale({ metric: true, imperial: true, position: 'bottomright' }).addTo(map);

            layers.street = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: '¬© OSM', crossOrigin: true });
            layers.google = L.tileLayer('http://mt0.google.com/vt/lyrs=y&hl=en&x={x}&y={y}&z={z}', { maxZoom: 20, subdomains: ['mt0','mt1','mt2','mt3'], attribution: '¬© Google', crossOrigin: 'anonymous' });
            layers.dark = L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', { attribution: '¬© CartoDB', crossOrigin: true });

            layers.street.addTo(map);

            drawnItems = new L.FeatureGroup();
            map.addLayer(drawnItems);
            helperLayer = new L.LayerGroup();
            map.addLayer(helperLayer);

            editHandler = new L.EditToolbar.Edit(map, { featureGroup: drawnItems, selectedPathOptions: { maintainColor: true, opacity: 0.8, weight: 4 } });

            map.on('click', closeContextMenu);
            map.on('movestart', closeContextMenu);
            map.on('mousemove', handleSnapMove);

            // Creation
            map.on(L.Draw.Event.CREATED, (e) => {
                const l = e.layer; const c = document.getElementById('colorPicker').value;
                if(l.setStyle) l.setStyle({ color:c, fillColor:c, weight: 4 });
                l.feature = { type:'Feature', properties:{ color:c } };

                attachContextMenu(l);
                drawnItems.addLayer(l);

                if(l instanceof L.Polyline || l instanceof L.Polygon) updateMeasurements(l);

                if(isEditMode) { editHandler.removeHooks(); editHandler.addHooks(); enableLiveEditHooks(); }
                resetTools();
                saveState();
            });

            // Edit Events
            map.on('draw:editresize', function(e) {
                updateCircleHelpers(e.layer);
                updateMeasurements(e.layer);
                clearTimeout(resizeTimer); resizeTimer = setTimeout(saveState, 500);
            });
            map.on('draw:editmove', function(e) {
                updateCircleHelpers(e.layer);
                updateMeasurements(e.layer);
            });
            map.on(L.Draw.Event.EDITED, saveState);
            map.on(L.Draw.Event.DELETED, saveState);

            saveState();
            setTimeout(checkForShareData, 500);
        }
        initMap();

        // --- Live Update Hooks ---
        function enableLiveEditHooks() {
            drawnItems.eachLayer(layer => {
                if ((layer instanceof L.Polygon || layer instanceof L.Polyline) && layer.editing && layer.editing.enabled()) {
                    const markers = layer.editing._markers;
                    if (markers) {
                        markers.forEach(marker => {
                            if (!marker._hasLiveUpdate) {
                                marker.on('drag', () => updateMeasurements(layer));
                                marker._hasLiveUpdate = true;
                            }
                        });
                    }
                }
            });
        }

        // --- Measurement Logic ---
        function updateMeasurements(layer) {
            if(layer.measurementLabels) {
                layer.measurementLabels.forEach(label => helperLayer.removeLayer(label));
            }
            layer.measurementLabels = [];

            if (layer instanceof L.Polygon) {
                // Area
                const area = L.GeometryUtil.geodesicArea(layer.getLatLngs()[0]);
                const areaStr = (area / 1000000).toFixed(2) + " km¬≤";
                const center = layer.getBounds().getCenter();

                const areaLabel = L.marker(center, {
                    icon: L.divIcon({ className: 'measure-label measure-label-area', html: areaStr, iconSize: [100, 20], iconAnchor: [50, 10] }),
                    interactive: false
                });
                helperLayer.addLayer(areaLabel);
                layer.measurementLabels.push(areaLabel);

                // Edges
                const latlngs = layer.getLatLngs()[0];
                for (let i = 0; i < latlngs.length; i++) {
                    const p1 = latlngs[i];
                    const p2 = latlngs[(i + 1) % latlngs.length];
                    const dist = map.distance(p1, p2);
                    const distStr = (dist / 1000).toFixed(2) + " km";
                    const midLat = (p1.lat + p2.lat) / 2;
                    const midLng = (p1.lng + p2.lng) / 2;

                    const edgeLabel = L.marker([midLat, midLng], {
                        icon: L.divIcon({ className: 'measure-label', html: distStr, iconSize: [100, 20], iconAnchor: [50, 10] }),
                        interactive: false
                    });
                    helperLayer.addLayer(edgeLabel);
                    layer.measurementLabels.push(edgeLabel);
                }
            }
            else if (layer instanceof L.Polyline && !(layer instanceof L.Polygon)) {
                let totalDist = 0;
                const latlngs = layer.getLatLngs();
                for (let i = 0; i < latlngs.length - 1; i++) {
                    totalDist += map.distance(latlngs[i], latlngs[i+1]);
                }
                const distStr = (totalDist / 1000).toFixed(2) + " km";
                const center = layer.getBounds().getCenter();
                const lineLabel = L.marker(center, {
                    icon: L.divIcon({ className: 'measure-label measure-label-area', html: distStr, iconSize: [100, 20], iconAnchor: [50, 10] }),
                    interactive: false
                });
                helperLayer.addLayer(lineLabel);
                layer.measurementLabels.push(lineLabel);
            }
        }

        // --- History ---
        function saveState() {
            if(isUndoingRedoing) return;
            const state = getMapState();
            const lastState = historyStack[historyStack.length - 1];
            if(JSON.stringify(state) !== JSON.stringify(lastState)) {
                historyStack.push(state);
                if(historyStack.length > 50) historyStack.shift();
                redoStack = [];
            }
        }

        function undo() {
            if(historyStack.length <= 1) return;
            isUndoingRedoing = true;
            const current = historyStack.pop();
            redoStack.push(current);
            const prev = historyStack[historyStack.length - 1];
            applyMapState(prev);
            isUndoingRedoing = false;
            showToast('Undo');
        }

        function redo() {
            if(redoStack.length === 0) return;
            isUndoingRedoing = true;
            const next = redoStack.pop();
            historyStack.push(next);
            applyMapState(next);
            isUndoingRedoing = false;
            showToast('Redo');
        }

        function getMapState() {
            const features = [];
            drawnItems.eachLayer(layer => {
                let type = 'unknown';
                let data = {};
                if (layer instanceof L.Circle) {
                    type = 'circle';
                    data = { lat: layer.getLatLng().lat, lng: layer.getLatLng().lng, radius: layer.getRadius(), color: layer.options.color };
                } else if (layer instanceof L.Marker && layer.feature && layer.feature.properties.type === 'text') {
                    type = 'text';
                    data = { lat: layer.getLatLng().lat, lng: layer.getLatLng().lng, content: layer.feature.properties.content, color: layer.feature.properties.color };
                } else if (layer.toGeoJSON) {
                    type = 'geojson';
                    const f = layer.toGeoJSON();
                    f.properties.color = layer.options.color;
                    data = f;
                }
                features.push({ type, data });
            });
            return features;
        }

        function applyMapState(features) {
            drawnItems.clearLayers();
            helperLayer.clearLayers();
            features.forEach(item => restoreItem(item));
            if(isEditMode) {
                editHandler.removeHooks();
                editHandler.addHooks();
                enableLiveEditHooks();
                drawnItems.eachLayer(l => { if(l instanceof L.Marker && l.dragging) l.dragging.enable(); });
            }
        }

        document.addEventListener('keydown', function(e) {
            if(e.target.tagName === 'INPUT') return;
            if((e.ctrlKey || e.metaKey) && e.key === 'z') {
                e.preventDefault();
                if(e.shiftKey) redo(); else undo();
            }
            if((e.ctrlKey || e.metaKey) && e.key === 'y') {
                e.preventDefault(); redo();
            }
        });

        function toggleSidebar() {
            const sidebar = document.getElementById('sidebarPanel');
            const openBtn = document.getElementById('sidebar-open-btn');
            if(sidebar.classList.contains('collapsed')) {
                sidebar.classList.remove('collapsed');
                openBtn.style.display = 'none';
            } else {
                sidebar.classList.add('collapsed');
                setTimeout(() => { openBtn.style.display = 'flex'; }, 300);
            }
            setTimeout(() => { map.invalidateSize(); }, 300);
        }

        // --- Helpers ---
        function getDestinationPoint(latlng, heading, distance) {
            const R = 6378137; const rad = Math.PI / 180;
            const lat1 = latlng.lat * rad; const lon1 = latlng.lng * rad;
            const angDist = distance / R; const trueCourse = heading * rad;
            const lat2 = Math.asin(Math.sin(lat1) * Math.cos(angDist) + Math.cos(lat1) * Math.sin(angDist) * Math.cos(trueCourse));
            const lon2 = lon1 + Math.atan2(Math.sin(trueCourse) * Math.sin(angDist) * Math.cos(lat1), Math.cos(angDist) - Math.sin(lat1) * Math.sin(lat2));
            return L.latLng(lat2 / rad, lon2 / rad);
        }

        function createCircleLayer(latlng, radius, color) {
            const circle = L.circle(latlng, { color: color, fillColor: color, fillOpacity: 0.2, radius: radius });
            const dot = L.circleMarker(latlng, { radius: 3, color: '#fff', weight: 1, fillColor: color, fillOpacity: 1, interactive: false });
            const rim = getDestinationPoint(L.latLng(latlng), 90, radius);
            const line = L.polyline([latlng, rim], { color: color, weight: 2, dashArray: '5, 5', interactive: false });

            const km = (radius / 1000).toFixed(2) + ' km';

            // Use a label marker instead of binding a tooltip to the line
            // This ensures we can update the text + position reliably in Leaflet 1.x
            const midPoint = L.latLng(
                (latlng.lat + rim.lat) / 2,
                (latlng.lng + rim.lng) / 2
            );
            const label = L.marker(midPoint, {
                icon: L.divIcon({
                    className: 'radius-label-marker',
                    html: km,
                    iconSize: [60, 20],
                    iconAnchor: [30, 10]
                }),
                interactive: false
            });

            circle.centerDot = dot;
            circle.radiusLine = line;
            circle.radiusLabel = label; // Store ref

            circle.feature = { type: 'Feature', properties: { type: 'circle', radius: radius, color: color } };

            attachContextMenu(circle);
            drawnItems.addLayer(circle);
            helperLayer.addLayer(dot);
            helperLayer.addLayer(line);
            helperLayer.addLayer(label);

            return circle;
        }

        function createTextLayer(latlng, text, color) {
            const icon = L.divIcon({ className: 'custom-div-icon', html: `<div class="custom-label" style="color:${color}; border-color:${color}">${text}</div>`, iconSize: [null, null], iconAnchor: [20, 10] });
            const marker = L.marker(latlng, { icon: icon, draggable: isEditMode });
            marker.feature = { type: 'Feature', properties: { type: 'text', content: text, color: color } };
            attachContextMenu(marker); drawnItems.addLayer(marker); return marker;
        }

        function updateCircleHelpers(circle) {
            if (!circle.centerDot || !circle.radiusLine || !circle.radiusLabel) return;
            const center = circle.getLatLng();
            const radius = circle.getRadius();

            // 1. Move Center Dot
            circle.centerDot.setLatLng(center);

            // 2. Move Radius Line
            const rim = getDestinationPoint(center, 90, radius);
            circle.radiusLine.setLatLngs([center, rim]);

            // 3. Move & Update Label
            const midPoint = L.latLng(
                (center.lat + rim.lat) / 2,
                (center.lng + rim.lng) / 2
            );
            circle.radiusLabel.setLatLng(midPoint);
            const km = (radius / 1000).toFixed(2) + ' km';

            // Efficiently update label text
            const icon = circle.radiusLabel.options.icon;
            icon.options.html = km;
            circle.radiusLabel.setIcon(icon);
        }

        // --- Tool Logic ---
        function activateTool(toolName) {
            resetTools();
            activeTool = toolName;
            const color = document.getElementById('colorPicker').value;
            if (toolName === 'polyline' || toolName === 'polygon') {
                document.getElementById('draw-helper').style.display = 'block';
                const handler = (toolName === 'polyline') ? L.Draw.Polyline : L.Draw.Polygon;
                nativeDrawHandler = new handler(map, {
                    shapeOptions: { color: color, weight: 4, opacity: 1 },
                    allowIntersection: false,
                    showLength: true,
                    metric: true
                });
                nativeDrawHandler.enable();
            } else if (toolName === 'fixedCircle') {
                document.getElementById('btnFixedCircle').classList.add('active');
                map.getContainer().style.cursor = 'copy';
                showToast('Click center point on map');
            } else if (toolName === 'text') {
                document.getElementById('btnTextTool').classList.add('active');
                map.getContainer().style.cursor = 'text';
                showToast('Click map to add text');
            }
        }

        function handleSnapMove(e) {
            if (!activeTool || (activeTool !== 'polyline' && activeTool !== 'polygon')) return;
            let minDist = Infinity; let nearest = null;
            drawnItems.eachLayer(layer => {
                if (layer instanceof L.Polygon || layer instanceof L.Polyline) {
                    const latlngs = layer.getLatLngs(); const flat = Array.isArray(latlngs[0]) ? latlngs.flat(2) : latlngs;
                    flat.forEach(pt => {
                        const pxDist = map.latLngToContainerPoint(e.latlng).distanceTo(map.latLngToContainerPoint(pt));
                        if (pxDist < 20 && pxDist < minDist) { minDist = pxDist; nearest = pt; }
                    });
                }
            });
            if (nearest) {
                if (!snapMarker) snapMarker = L.marker(nearest, { icon: L.divIcon({ className: 'snap-marker', iconSize: [16, 16], iconAnchor: [8, 8] }), interactive: false }).addTo(map);
                else { snapMarker.setLatLng(nearest); snapMarker.setOpacity(1); }
                snapTarget = nearest;
            } else { if (snapMarker) snapMarker.setOpacity(0); snapTarget = null; }
        }

        function resetTools() {
            activeTool = null;
            document.getElementById('draw-helper').style.display = 'none';
            if (nativeDrawHandler) { nativeDrawHandler.disable(); nativeDrawHandler = null; }
            document.querySelectorAll('.btn').forEach(b => b.classList.remove('active'));
            if(isEditMode) document.getElementById('btnEditMode').classList.add('active');
            map.getContainer().style.cursor = '';
            if(snapMarker) snapMarker.setOpacity(0);
        }

        map.on('click', function(e) {
            const color = document.getElementById('colorPicker').value;
            if (activeTool === 'fixedCircle') {
                const km = 5;
                createCircleLayer(e.latlng, km * 1000, color);
                saveState();
                if(!isEditMode) toggleEditMode();
                resetTools();
            } else if (activeTool === 'text') {
                setTimeout(() => {
                    const text = prompt("Enter Text:");
                    if (text) { createTextLayer(e.latlng, text, color); resetTools(); saveState(); }
                }, 50);
            }
        });

        // --- Edit Mode ---
        function toggleEditMode(forceOn = false) {
            if(forceOn && isEditMode) return;
            isEditMode = !isEditMode;
            const btn = document.getElementById('btnEditMode');
            if (isEditMode) {
                btn.classList.add('active');
                btn.innerHTML = '<i class="fa-solid fa-check"></i> <span>Editing Active</span>';
                editHandler.enable();
                enableLiveEditHooks(); // Bind live updates for Polys
                drawnItems.eachLayer(l => { if(l instanceof L.Marker && l.dragging) l.dragging.enable(); });
                showToast("You can now drag & resize items");
            } else {
                btn.classList.remove('active');
                btn.innerHTML = '<i class="fa-solid fa-arrows-up-down-left-right"></i> <span>Enable Drag & Edit</span>';
                editHandler.disable();
                drawnItems.eachLayer(l => { if(l instanceof L.Marker && l.dragging) l.dragging.disable(); });
                editHandler.save();
            }
        }

        function attachContextMenu(layer) {
            layer.on('contextmenu', e => { L.DomEvent.stopPropagation(e); openContextMenu(e, layer); });

            if (layer instanceof L.Circle) {
                layer.on('move', () => updateCircleHelpers(layer));
                layer.on('drag', () => updateCircleHelpers(layer));
                layer.on('edit', () => updateCircleHelpers(layer));

                layer.on('dragend', saveState);
                layer.on('moveend', saveState);
            }
            if(layer instanceof L.Marker) {
                layer.on('dragend', saveState);
            }
            if (layer instanceof L.Polyline || layer instanceof L.Polygon) {
                layer.on('edit', () => updateMeasurements(layer));
                layer.on('dragend', saveState);
                layer.on('edit', saveState);
            }
        }

        function openContextMenu(e, layer) {
            ctxTargetLayer = layer;
            const menu = document.getElementById('context-menu');
            document.getElementById('ctx-text-group').style.display = 'none';
            document.getElementById('ctx-radius-group').style.display = 'none';

            if (layer instanceof L.Circle) {
                document.getElementById('ctx-radius-group').style.display = 'block';
                document.getElementById('ctx-radius-input').value = (layer.getRadius()/1000).toFixed(2);
                document.getElementById('ctx-color-input').value = layer.options.color || '#000000';
            } else if (layer instanceof L.Marker) {
                document.getElementById('ctx-text-group').style.display = 'block';
                const div = document.createElement('div'); div.innerHTML = layer.options.icon.options.html;
                document.getElementById('ctx-text-input').value = div.innerText;
                const match = div.innerHTML.match(/color:(#[0-9a-fA-F]+)/);
                if(match) document.getElementById('ctx-color-input').value = match[1];
            } else { document.getElementById('ctx-color-input').value = layer.options.color || '#000000'; }
            const pt = map.mouseEventToContainerPoint(e.originalEvent);
            menu.style.left = pt.x + 'px'; menu.style.top = pt.y + 'px';
            menu.style.display = 'block';
        }

        function closeContextMenu() { document.getElementById('context-menu').style.display='none'; }

        function saveContextEdit() {
            if (!ctxTargetLayer) return;
            const color = document.getElementById('ctx-color-input').value;
            if (ctxTargetLayer instanceof L.Circle) {
                const m = parseFloat(document.getElementById('ctx-radius-input').value) * 1000;
                ctxTargetLayer.setRadius(m);
                ctxTargetLayer.setStyle({ color: color, fillColor: color });
                if(ctxTargetLayer.centerDot) ctxTargetLayer.centerDot.setStyle({ fillColor: color });
                if(ctxTargetLayer.radiusLine) ctxTargetLayer.radiusLine.setStyle({ color: color });
                updateCircleHelpers(ctxTargetLayer);
                if(ctxTargetLayer.feature) { ctxTargetLayer.feature.properties.radius = m; ctxTargetLayer.feature.properties.color = color; }
            } else if (ctxTargetLayer instanceof L.Marker) {
                const txt = document.getElementById('ctx-text-input').value;
                ctxTargetLayer.setIcon(L.divIcon({ className:'custom-div-icon', html:`<div class="custom-label" style="color:${color}; border-color:${color}">${txt}</div>`, iconSize:[null,null], iconAnchor:[20,10] }));
                if(ctxTargetLayer.feature) ctxTargetLayer.feature.properties = { type:'text', content:txt, color:color };
            } else {
                ctxTargetLayer.setStyle({ color: color, fillColor: color });
                if(ctxTargetLayer.feature) ctxTargetLayer.feature.properties.color = color;
            }
            closeContextMenu();
            saveState();
        }

        function deleteContextLayer() {
            if (ctxTargetLayer) {
                if(ctxTargetLayer.centerDot) helperLayer.removeLayer(ctxTargetLayer.centerDot);
                if(ctxTargetLayer.radiusLine) helperLayer.removeLayer(ctxTargetLayer.radiusLine);
                if(ctxTargetLayer.radiusLabel) helperLayer.removeLayer(ctxTargetLayer.radiusLabel);
                if(ctxTargetLayer.measurementLabels) ctxTargetLayer.measurementLabels.forEach(l => helperLayer.removeLayer(l));
                drawnItems.removeLayer(ctxTargetLayer);
                closeContextMenu();
                saveState();
            }
        }

        // --- Share Logic ---
        function generateShareLink() {
            const state = { c: [map.getCenter().lat, map.getCenter().lng], z: map.getZoom(), d: getMapState() };
            const json = JSON.stringify(state);
            const encoded = btoa(unescape(encodeURIComponent(json)));
            const url = window.location.origin + window.location.pathname + '?map=' + encoded;
            document.getElementById('share-url-box').innerText = url;
            document.getElementById('share-modal').style.display = 'flex';
        }

        function copyShareLink() {
            const text = document.getElementById('share-url-box').innerText;
            navigator.clipboard.writeText(text).then(() => showToast('Link copied!'));
        }

        function checkForShareData() {
            const params = new URLSearchParams(window.location.search);
            const mapData = params.get('map');
            if (mapData) {
                try {
                    const json = decodeURIComponent(escape(atob(mapData)));
                    const state = JSON.parse(json);
                    if(state.c && state.z) map.setView(state.c, state.z);
                    if(state.d && Array.isArray(state.d)) applyMapState(state.d);
                    showToast('Map restored from link');
                } catch (e) { console.error("Share load error:", e); showToast('Invalid Share Link', true); }
            }
        }

        function restoreItem(item) {
            if (!item.type || !item.data) return;
            const d = item.data;
            let color = d.color || (d.properties ? d.properties.color : '#000000');
            if (item.type === 'circle') createCircleLayer([d.lat, d.lng], d.radius, color);
            else if (item.type === 'text') createTextLayer([d.lat, d.lng], d.content, color);
            else if (item.type === 'geojson') {
                L.geoJSON(d, {
                    style: { color: color, weight: 4, opacity: 1 },
                    onEachFeature: (f, l) => {
                        l.options.color = color;
                        attachContextMenu(l);
                        drawnItems.addLayer(l);
                        if(l instanceof L.Polyline || l instanceof L.Polygon) updateMeasurements(l);
                    }
                });
            }
        }

        // --- Fixed Export (Snapshot Mode) ---
        function exportImage() {
            document.getElementById('loader').style.display='flex';
            document.body.classList.add('capture-mode');
            map.invalidateSize();
            setTimeout(() => {
                const mapEl = document.getElementById('map');
                html2canvas(mapEl, {
                    useCORS: true, allowTaint: false,
                    width: window.innerWidth, height: window.innerHeight,
                    scrollX: 0, scrollY: 0, x: 0, y: 0, scale: window.devicePixelRatio
                }).then(c => {
                    const a = document.createElement('a');
                    a.href = c.toDataURL('image/png'); a.download='map-export.png'; a.click();
                    document.body.classList.remove('capture-mode');
                    map.invalidateSize();
                    document.getElementById('loader').style.display='none';
                }).catch(e => {
                    console.error(e); alert('Export failed.');
                    document.body.classList.remove('capture-mode');
                    map.invalidateSize();
                    document.getElementById('loader').style.display='none';
                });
            }, 1000);
        }
    </script>
</body>
</html>
